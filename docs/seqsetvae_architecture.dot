digraph SeqSetVAE {
  rankdir=LR;
  node [shape=box, style=rounded];

  subgraph cluster_data {
    label="Data Pipeline";
    A1[label="patient.parquet (variable,value,minute,set_index)"];
    A2[label="cached.csv -> variable embedding"];
    A3[label="stats.csv -> z-score val"];
    A4[label="oc.csv -> label"];
    B1[label="SeqSetVAEDataModule\n(dynamic_collate_fn)"];
    B2[label="var [B,N,D]"];
    B3[label="val [B,N,1]"];
    B4[label="minute [B,N,1]"];
    B5[label="set_id [B,N,1]"];
    B6[label="label [B]"];
    B7[label="padding_mask [B,N]"];
    A1 -> B1;
    B1 -> B2; B1 -> B3; B1 -> B4; B1 -> B5; B1 -> B6; B1 -> B7;
  }

  subgraph cluster_setvae {
    label="Per-timestep Set Encoder (SetVAE)";
    C1[label="DimReducer (optional)\nLinear D->reduced_dim"];
    C2[label="Normalize: x = normalize(var_reduced) * val"];
    C3[label="Embed Linear+LN+GELU"];
    C4[label="Encoder Lx: ISAB -> agg(mean) -> mu,logvar -> rsample z"];
    C5[label="Decoder Lx: Attentive Bottleneck -> PMA"];
    C6[label="Recon head Linear -> recon set"];
  }

  subgraph cluster_time {
    label="Temporal Fusion";
    D1[label="stack z_sample -> z_seq [B,S,D]"];
    D2[label="PE: learned pos_emb âŠ— sin(idx) + time_encoder(minute)"];
    D3[label="LayerNorm"];
    D4[label="TransformerEncoder (nhead, ff_dim, dropout, norm_first)\ncausal mask + random holes"];
    D5[label="Post-Transformer LayerNorm"];
  }

  subgraph cluster_heads {
    label="Heads";
    E1[label="_SetDecoder per t: h_t -> recon_t"];
    E2[label="Multi-scale pooling on h_seq\nAvgPool + MaxPool + MHA attention pooling"];
    E3[label="Concat -> Linear+LN+ReLU+Dropout -> features [B,D]"];
    E4[label="Classifier MLP (3 layers) -> logits [B,C]"];
  }

  subgraph cluster_losses {
    label="Losses";
    F1[label="Recon: Chamfer(dir+mag+vec) + variance term"];
    F2[label="KL (free-bits + var/mean reg) over SetVAE layers"];
    F3[label="Pred: CE or FocalLoss (AUC mode)"];
    F4[label="Schedules: beta warmup, dynamic weights"];
  }

  B2 -> C1 -> C2 -> C3 -> C4;
  C4 -> D1 [label="z_list[-1].z_sample"];
  C4 -> F2 [label="mu, logvar"];
  C4 -> C5 -> C6 -> F1 [label="recon set"];

  D1 -> D2 -> D3 -> D4 -> D5;
  D5 -> E1 -> F1;
  D5 -> E2 -> E3 -> E4 -> F3;

  {F1, F2, F3} -> G [label="sum with weights"];
  F4 -> G [style=dashed];
  G[label="Total Loss"];
}